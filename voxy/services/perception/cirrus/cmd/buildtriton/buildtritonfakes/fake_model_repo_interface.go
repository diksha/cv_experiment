// Code generated by counterfeiter. DO NOT EDIT.
package buildtritonfakes

import (
	"sync"

	cirruspb "github.com/voxel-ai/voxel/protos/perception/cirrus/v1"
	graphconfigpb "github.com/voxel-ai/voxel/protos/perception/graph_config/v1"
	"github.com/voxel-ai/voxel/services/perception/cirrus/cmd/buildtriton"
)

type FakeModelRepoInterface struct {
	GetEnsemblesFromTritonConfigStub        func(map[string]*cirruspb.Ensemble, map[string]*graphconfigpb.GraphConfig) ([]*cirruspb.Ensemble, error)
	getEnsemblesFromTritonConfigMutex       sync.RWMutex
	getEnsemblesFromTritonConfigArgsForCall []struct {
		arg1 map[string]*cirruspb.Ensemble
		arg2 map[string]*graphconfigpb.GraphConfig
	}
	getEnsemblesFromTritonConfigReturns struct {
		result1 []*cirruspb.Ensemble
		result2 error
	}
	getEnsemblesFromTritonConfigReturnsOnCall map[int]struct {
		result1 []*cirruspb.Ensemble
		result2 error
	}
	GetModelsFromTritonConfigStub        func(map[string]*cirruspb.Model, map[string]*graphconfigpb.GraphConfig) ([]*cirruspb.Model, error)
	getModelsFromTritonConfigMutex       sync.RWMutex
	getModelsFromTritonConfigArgsForCall []struct {
		arg1 map[string]*cirruspb.Model
		arg2 map[string]*graphconfigpb.GraphConfig
	}
	getModelsFromTritonConfigReturns struct {
		result1 []*cirruspb.Model
		result2 error
	}
	getModelsFromTritonConfigReturnsOnCall map[int]struct {
		result1 []*cirruspb.Model
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeModelRepoInterface) GetEnsemblesFromTritonConfig(arg1 map[string]*cirruspb.Ensemble, arg2 map[string]*graphconfigpb.GraphConfig) ([]*cirruspb.Ensemble, error) {
	fake.getEnsemblesFromTritonConfigMutex.Lock()
	ret, specificReturn := fake.getEnsemblesFromTritonConfigReturnsOnCall[len(fake.getEnsemblesFromTritonConfigArgsForCall)]
	fake.getEnsemblesFromTritonConfigArgsForCall = append(fake.getEnsemblesFromTritonConfigArgsForCall, struct {
		arg1 map[string]*cirruspb.Ensemble
		arg2 map[string]*graphconfigpb.GraphConfig
	}{arg1, arg2})
	stub := fake.GetEnsemblesFromTritonConfigStub
	fakeReturns := fake.getEnsemblesFromTritonConfigReturns
	fake.recordInvocation("GetEnsemblesFromTritonConfig", []interface{}{arg1, arg2})
	fake.getEnsemblesFromTritonConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeModelRepoInterface) GetEnsemblesFromTritonConfigCallCount() int {
	fake.getEnsemblesFromTritonConfigMutex.RLock()
	defer fake.getEnsemblesFromTritonConfigMutex.RUnlock()
	return len(fake.getEnsemblesFromTritonConfigArgsForCall)
}

func (fake *FakeModelRepoInterface) GetEnsemblesFromTritonConfigCalls(stub func(map[string]*cirruspb.Ensemble, map[string]*graphconfigpb.GraphConfig) ([]*cirruspb.Ensemble, error)) {
	fake.getEnsemblesFromTritonConfigMutex.Lock()
	defer fake.getEnsemblesFromTritonConfigMutex.Unlock()
	fake.GetEnsemblesFromTritonConfigStub = stub
}

func (fake *FakeModelRepoInterface) GetEnsemblesFromTritonConfigArgsForCall(i int) (map[string]*cirruspb.Ensemble, map[string]*graphconfigpb.GraphConfig) {
	fake.getEnsemblesFromTritonConfigMutex.RLock()
	defer fake.getEnsemblesFromTritonConfigMutex.RUnlock()
	argsForCall := fake.getEnsemblesFromTritonConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeModelRepoInterface) GetEnsemblesFromTritonConfigReturns(result1 []*cirruspb.Ensemble, result2 error) {
	fake.getEnsemblesFromTritonConfigMutex.Lock()
	defer fake.getEnsemblesFromTritonConfigMutex.Unlock()
	fake.GetEnsemblesFromTritonConfigStub = nil
	fake.getEnsemblesFromTritonConfigReturns = struct {
		result1 []*cirruspb.Ensemble
		result2 error
	}{result1, result2}
}

func (fake *FakeModelRepoInterface) GetEnsemblesFromTritonConfigReturnsOnCall(i int, result1 []*cirruspb.Ensemble, result2 error) {
	fake.getEnsemblesFromTritonConfigMutex.Lock()
	defer fake.getEnsemblesFromTritonConfigMutex.Unlock()
	fake.GetEnsemblesFromTritonConfigStub = nil
	if fake.getEnsemblesFromTritonConfigReturnsOnCall == nil {
		fake.getEnsemblesFromTritonConfigReturnsOnCall = make(map[int]struct {
			result1 []*cirruspb.Ensemble
			result2 error
		})
	}
	fake.getEnsemblesFromTritonConfigReturnsOnCall[i] = struct {
		result1 []*cirruspb.Ensemble
		result2 error
	}{result1, result2}
}

func (fake *FakeModelRepoInterface) GetModelsFromTritonConfig(arg1 map[string]*cirruspb.Model, arg2 map[string]*graphconfigpb.GraphConfig) ([]*cirruspb.Model, error) {
	fake.getModelsFromTritonConfigMutex.Lock()
	ret, specificReturn := fake.getModelsFromTritonConfigReturnsOnCall[len(fake.getModelsFromTritonConfigArgsForCall)]
	fake.getModelsFromTritonConfigArgsForCall = append(fake.getModelsFromTritonConfigArgsForCall, struct {
		arg1 map[string]*cirruspb.Model
		arg2 map[string]*graphconfigpb.GraphConfig
	}{arg1, arg2})
	stub := fake.GetModelsFromTritonConfigStub
	fakeReturns := fake.getModelsFromTritonConfigReturns
	fake.recordInvocation("GetModelsFromTritonConfig", []interface{}{arg1, arg2})
	fake.getModelsFromTritonConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeModelRepoInterface) GetModelsFromTritonConfigCallCount() int {
	fake.getModelsFromTritonConfigMutex.RLock()
	defer fake.getModelsFromTritonConfigMutex.RUnlock()
	return len(fake.getModelsFromTritonConfigArgsForCall)
}

func (fake *FakeModelRepoInterface) GetModelsFromTritonConfigCalls(stub func(map[string]*cirruspb.Model, map[string]*graphconfigpb.GraphConfig) ([]*cirruspb.Model, error)) {
	fake.getModelsFromTritonConfigMutex.Lock()
	defer fake.getModelsFromTritonConfigMutex.Unlock()
	fake.GetModelsFromTritonConfigStub = stub
}

func (fake *FakeModelRepoInterface) GetModelsFromTritonConfigArgsForCall(i int) (map[string]*cirruspb.Model, map[string]*graphconfigpb.GraphConfig) {
	fake.getModelsFromTritonConfigMutex.RLock()
	defer fake.getModelsFromTritonConfigMutex.RUnlock()
	argsForCall := fake.getModelsFromTritonConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeModelRepoInterface) GetModelsFromTritonConfigReturns(result1 []*cirruspb.Model, result2 error) {
	fake.getModelsFromTritonConfigMutex.Lock()
	defer fake.getModelsFromTritonConfigMutex.Unlock()
	fake.GetModelsFromTritonConfigStub = nil
	fake.getModelsFromTritonConfigReturns = struct {
		result1 []*cirruspb.Model
		result2 error
	}{result1, result2}
}

func (fake *FakeModelRepoInterface) GetModelsFromTritonConfigReturnsOnCall(i int, result1 []*cirruspb.Model, result2 error) {
	fake.getModelsFromTritonConfigMutex.Lock()
	defer fake.getModelsFromTritonConfigMutex.Unlock()
	fake.GetModelsFromTritonConfigStub = nil
	if fake.getModelsFromTritonConfigReturnsOnCall == nil {
		fake.getModelsFromTritonConfigReturnsOnCall = make(map[int]struct {
			result1 []*cirruspb.Model
			result2 error
		})
	}
	fake.getModelsFromTritonConfigReturnsOnCall[i] = struct {
		result1 []*cirruspb.Model
		result2 error
	}{result1, result2}
}

func (fake *FakeModelRepoInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getEnsemblesFromTritonConfigMutex.RLock()
	defer fake.getEnsemblesFromTritonConfigMutex.RUnlock()
	fake.getModelsFromTritonConfigMutex.RLock()
	defer fake.getModelsFromTritonConfigMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeModelRepoInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ buildtriton.ModelRepoInterface = new(FakeModelRepoInterface)
